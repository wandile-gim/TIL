# [Docker] Volume.. bind Mount..

개발 환경에서 도커를 이용하면 편리한 점이 많은데 이 중에서 도커가 제공하는 방식 세가지가 있다.

- **Volume**
- **Bind mounts**
- **tmpfs**



요즘 개발하고 있는 환경에서는 Volume과 Bind mounts를 사용해서 볼륨을 설정, 운용하고 있는데 사용하면서 어림잡아 짐작하는 상황이 🤷‍♂️ 있어서 정리하고 넘어가려고 한다.



#### 우선 첫번 째 상황

:arrow_right:  어떨 때는 로컬환경에서 파일을 저장했는데 run시 변경된 파일이 적용 되었고, 안되었을 때가 있었다. 그럴 때마다 애매하게 build --no-cache로 빌드를 다시 해줬다.

그럴 필요가 없는게, bind mount를 해주면 Application의 파일과 구조가 Container에서도 동일하기 때문에 bind mount를 사용하여 볼륨을 운용한다. 

상황을 다시 떠올려 파악해보면, 단지 볼륨 마운트가 되어있지 않았던 것인데 우선순위를 나중으로 두었던 탔에 명확한 정리가 되어있지 않아 내버려뒀던 불편한 진실이었다.



#### 두번 째 상황

:arrow_right: Dockerfile을 정의하고 빌드 할 때 COPY command로 디렉터리의 파일들을 복사해 프레임워크의 의존성을 옮겼을 때 /app이라는 경로가 동일해 실제로 작동하는 바운드 마운트의 경로와 겹쳐 overwirtten되었다. 

(의존성을 설치하면 생기는 디폴트 경로가 바운드 마운트되는 경로와 겹쳐서)

도커는 볼륨의 경로를 비교할 때 더 길고 구체적인 경로를 채택하는데, 그렇기 때문에 익명 볼륨을 지정해주어 /app/foo로 바인딩 시켜줘 외부에서 발생한 유입인, 볼륨 때문에 발생한 문제를 덮어써 두 개의 볼륨을 공존 시킬 수 있다.



기본적으로 DB와 같이 컨테이너가 중지되거나 제거되도 유지되는 볼륨은 volume으로 생성해 명시해줘야 하기에 compose를 사용해 올리고 내릴 때 영향을 고려하지 않았지만,

익명 볼륨이나 bind mount된 볼륨에 대한 지식이 명확하지 않았기 때문에 여러 상황들을 직접 겪으며 트러블 슈팅을 통해 이해가 수월했던(?)것 같다.



아 볼륨을 지정할 때 헷갈렸던게 있었는데,

```shell
volumes:
	- ${local}:${container} # 콜론 앞에 로컬 머신 경로가 붙으면 바인드 마운트가 되고,
	- db-data:/var/lib/postgresql/data # 경로가 아닌 것이 붙으면 볼륨이름으로 취급되어 명명된 볼륨이 된다.
```



$조금.. 레벨업?$

![LEVEL UP](https://cdn-images-1.medium.com/max/600/1*A75aHpsiGwYp1oXnI75TYA.jpeg){: width="50px" height="50px"}